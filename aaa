/*

1 what is pico?
pico:  object detection with pixel intensity comparisons organized in decision trees[2].
we use a machine learning algorithm to discover the structure in the problem rather than assuming one a priori.
We formulate the problem of pupil localization as regression
based on low-level image features.
2 pico framework.
vj=haar-like feature+adaboost+cascade.
 Pico is a modification of vj framework.
Pico=pixel intensity comparisons + gentle boost + chain-like cascade
3 The reason we use pico instead of pixels is that all the discriminating power derives from relative angles and distances among tags[1].
4 pico binary test:
binTest(I; I1,I2) equals 0 if I(I1)<I(I2), equals 1 otherwise. Here I1 and I2 are coordinates drawn from [-1,1]x[-1,1].
5 How to select binary test?
We select binary test in each internal node of our tree in a way to minimize the weighted mean squared error obtained when training data is split by the test.
5.2
The parameters of each binary test in internal nodes of the tree are optimized in a way to maximize clustering quality obtained when the incoming training data is split by the test.
The output at each leaf node is obtained as the mean of pupil coordinates arriving at that node.
6 difference with vj algorithm.
Vj uses the best haar-like feature as its weak classifier which can be viewed tree of depth 1, but pico uses tree of some depth instead.
pico feature is simpler than Haar-like features.
Haar-like features do not perform random perturbations in runtime, as they are based on region averaging which is equivalent to low pass filtering and this makes them more robust to aliasing and noise.
7 Ensemble of trees
Pico uses GentleBoost and vj uses AdaBoost.( almost same)
It is well known that a single tree will most likely overfit
the training data. On the other hand, an ensemble of trees
can achieve impressive results. 
Randomized trees were a natural choice in our case due to the fact that they handle large training sets with multiple inputs and outputs, and their high generalization power and fast computation.
7.2
Regression trees
Regression trees [5] are tools for function approximation. The basic idea is to split recursively the original problem into two simpler ones, each solvable by a model of reduced complexity. The splits are performed at internal nodes of the tree, based on problem-specific binary tests. Terminal nodes contain simple models that approximate the desired output. In practice, we treat the tree construction process as a supervised learning problem. In other words, we have to choose the binary tests in internal nodes and output models at terminal nodes based on a finite set of input-output pairs in a training set.
7.3
The binary tests at internal nodes of the tree are based on pixel intensity differences. This results in their resolution independence and means that the binary tests can easily be resized based on the data.
Each terminal node of the tree contains a constant vector
that models the output.
8 Cascade:
Vj uses cascade to reject non-objects at early stages, with little processing time spent.
Pico uses chain-like cascade, which is much like vj cascade, but also uses previous stage as an additional information to improve current stage’s discriminability, thus improving convergence of each stage classifier[3].
9 The advantages of pico compared with vj.
One, does not require computation of integral images.
Two, all binary tests in internal nodes of the trees are based on the same feature, but vj used 5 different types.
Three, no need for image pre-processing( such as normalization, resizing, smoothing).
Four, can easily be modified for fast detection of in-plane rotated objects.
10 We conjecture that it is possible to obtain even better results with more advanced cascade construction/optimization techniques.
References
[1] Nenad Markuˇs, Miroslav Frljak, Igor S. Pandˇzi´c, J¨orgen Ahlberg and Robert Forchheimer. Object Detection with Pixel Intensity Comparisons Organized in Decision Trees. Computer Science,  14(4):2657-62, 2013.
[2] Y. Amit and D. Geman. Shape quantization and recognition with randomized trees. Neural Computation, 9:1545–1588, 1997.
[3] R. Xiao, L. Zhu, and H.-J. Zhang. Boosting chain learning for object detection. In ICCV, volume 1, pages 709–715, 2003.


 */
